---
- name: Import vars
  run_once: true
  include_vars:
    file: inventory/local/cluster-variable.yaml
    name: vardata

##This is just here for restoring vms from snapshots, comment out if not needed##################################
- name: time synch...for when restoring from snap
  become: true
  shell: "{{ item }}"
  with_items:    
    - "date -s \"$(wget -qSO- --max-redirect=0 google.com 2>&1 | grep Date: | cut -d' ' -f5-8)Z\""
  register: command_output 

######Check for kube api service, create join commands if running###########################################
- name: Check if kube-apiserver is running
  shell: pgrep kube-apiserver
  register: kube_apiserver_status
  ignore_errors: true

- name: Show kube-apiserver processes (if running)
  debug:
    msg: "{{ kube_apiserver_status.stdout_lines }}"
  when: kube_apiserver_status.rc == 0

- name: Generate kubeadm join command (if kube-apiserver is running)
  become: true
  command: kubeadm token create --print-join-command
  register: kubeadm_join_command
  when: kube_apiserver_status.rc == 0

- name: Save join command to file on controller node
  become: true
  copy:
    dest: /etc/joincluster
    content: "{{ kubeadm_join_command.stdout }}"
    owner: root
    group: root
    mode: '0600'
  when: kube_apiserver_status.rc == 0

- name: Save join command to file on Ansible control host
  delegate_to: localhost
  copy:
    dest: /etc/joincluster
    content: "{{ kubeadm_join_command.stdout }}"
    owner: "{{ ansible_user | default('root') }}"
    group: "{{ ansible_user | default('root') }}"
    mode: '0600'
  when: kube_apiserver_status.rc == 0

- name: Read kubeconfig into variable (if kube-apiserver is running)
  become: true
  slurp:
    src: "{{ ansible_env.HOME }}/.kube/config"
  register: kubeconfig_content
  when: kube_apiserver_status.rc == 0

- name: Show kubeconfig content (decoded)
  debug:
    msg: "{{ kubeconfig_content.content | b64decode }}"
  when: kube_apiserver_status.rc == 0

#######If kube api running, get kube config###################################################################################
- name: Read kubeconfig into variable
  become: true
  ansible.builtin.slurp:
    src: "$HOME/.kube/config"
  register: kubecfg_raw
  when: kube_apiserver_status.rc == 0

- name: Decode kubeconfig content
  ansible.builtin.set_fact:
    kubecfg: "{{ kubecfg_raw.content | b64decode }}"
  when: kube_apiserver_status.rc == 0

- name: Ensure local kubeconfig file exists
  ansible.builtin.file:
    path: "/etc/kubeconfig"
    state: touch
    owner: root
    group: root
    mode: '0600'
  delegate_to: localhost
  when: kube_apiserver_status.rc == 0

- name: Write kubeconfig content to local file
  ansible.builtin.copy:
    dest: "/etc/kubeconfig"
    content: "{{ kubecfg }}"
    owner: root
    group: root
    mode: '0600'
  delegate_to: localhost
  when: kube_apiserver_status.rc == 0

- meta: end_host
  when: kube_apiserver_status.rc == 0

###########If kubeapi not running install ContainerD, NFS common, kube binaries installed#############################################
- name: Install ContainerD
  apt:
    name:  containerd
    state: present
    update_cache: true

- name: Install NFS client package
  apt:
    name:  nfs-common
    state: present
    update_cache: true

- name: Create keyrings directory
  ansible.builtin.file:
    path: /etc/apt/keyrings
    state: directory
    mode: '0755'

- name: Download Releasekey  
  become: true
  ansible.builtin.get_url: 
    url: "https://pkgs.k8s.io/core:/stable:/v{{ vardata.kube_version }}/deb/Release.key"
    dest: "/etc/apt/keyrings/kubernetes-Release.key"
    mode: '0644'

- name: Convert Release key to GPG keyring
  ansible.builtin.command:
    cmd: "gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg /etc/apt/keyrings/kubernetes-Release.key"
  args:
    creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg

- name: Add Kubernetes APT repository
  ansible.builtin.apt_repository:
    repo: "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v{{ vardata.kube_version }}/deb/ /"
    filename: kubernetes
    state: present

- name: Update apt repo and cache on all Debian/Ubuntu boxes
  apt: update_cache=yes force_apt_get=yes cache_valid_time=3600

- name: Upgrade all packages on servers
  apt: upgrade=dist force_apt_get=yes

- name: Check if a reboot is needed on all servers
  register: reboot_required_file
  stat: path=/var/run/reboot-required

- name: Reboot the box if kernel updated
  reboot:
    msg: "Reboot initiated by Ansible for kernel updates"
    connect_timeout: 5
    reboot_timeout: 300
    pre_reboot_delay: 0
    post_reboot_delay: 30
    test_command: uptime
  when: reboot_required_file.stat.exists

- name: Install kubeadm, kubelet, and kubectl
  apt:
    name: "{{ item }}"
    state: present
    update_cache: true
  loop:
    - kubeadm
    - kubelet
    - kubectl

######Set System parameters for kubernetes###############################################

- name: Disable swap immediately
  command: swapoff -a

- name: Comment out swap entries in /etc/fstab
  lineinfile:
    path: /etc/fstab
    regexp: '^([^#].* swap )'
    line: '#\1'
    backrefs: yes

- name: Mask swap.target
  systemd:
    name: swap.target
    masked: yes

- name: Disable IPv6
  sysctl:
    name: net.ipv6.conf.all.disable_ipv6
    value: 1
    sysctl_set: yes
    state: present
    reload: yes

- name: Comment swap lines in /etc/fstab (alternative approach)
  replace:
    path: /etc/fstab
    regexp: '^(\s*[^#].*\s+swap\s+)'
    replace: '#\1'

- name: Ensure containerd modules are loaded at boot
  copy:
    dest: /etc/modules-load.d/containerd.conf
    content: |
      overlay
      br_netfilter
    owner: root
    group: root
    mode: '0644'

- name: Load overlay module now
  modprobe:
    name: overlay
    state: present

- name: Load br_netfilter module now
  modprobe:
    name: br_netfilter
    state: present

- name: Ensure Kubernetes sysctl settings
  copy:
    dest: /etc/sysctl.d/kubernetes.conf
    content: |
      net.bridge.bridge-nf-call-ip6tables = 1
      net.bridge.bridge-nf-call-iptables = 1
      net.ipv4.ip_forward = 1
    owner: root
    group: root
    mode: '0644'

- name: Apply sysctl settings
  command: sysctl --system

- name: Add KUBELET_EXTRA_ARGS to /etc/default/kubelet
  copy:
    dest: /etc/default/kubelet
    content: |
      KUBELET_EXTRA_ARGS="--cgroup-driver=cgroupfs"
    owner: root
    group: root
    mode: '0644'

- name: Ensure net.ipv4.ip_forward is set to 1 persistently
  ansible.builtin.sysctl:
    name: net.ipv4.ip_forward
    value: '1'
    sysctl_file: /etc/sysctl.conf
    state: present
    reload: yes

- name: Reload systemd manager configuration
  systemd:
    daemon_reload: yes

- name: Restart kubelet
  systemd:
    name: kubelet
    state: restarted

#END
#########################################################################################
#- name: system parameters for K8s initiate
#  become: true
#  shell: "{{ item }}"
#  with_items:
#          - "swapoff -a"
#          - "sed -e '/swap/ s/^#*/#/' -i /etc/fstab"
#          - "systemctl mask swap.target"
#          - "sysctl -w net.ipv6.conf.all.disable_ipv6=1"
#          - "sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab"
#          - "printf '%s\\n' 'overlay' 'br_netfilter' >/etc/modules-load.d/containerd.conf"
#          - "modprobe overlay"
#          - "modprobe br_netfilter"
#          - "printf '%s\\n' 'net.bridge.bridge-nf-call-ip6tables = 1' 'net.bridge.bridge-nf-call-iptables = 1' 'net.ipv4.ip_forward = 1' >/etc/sysctl.d/kubernetes.conf"
#          - "sysctl --system"
#          - "printf '%s\\n' 'KUBELET_EXTRA_ARGS=\"--cgroup-driver=cgroupfs\"'  >/etc/default/kubelet"
#          - "systemctl daemon-reload && sudo systemctl restart kubelet"

#  register: key
  #- debug:
  #   msg:
  #     - "{{ key.stdout }}"

#- name: Delete banner file before copy
#  file:
#    path: "/etc/issue.net"
#    state: absent

#- name: Create new banner file
#  file:
#      path: "/etc/issue.net"
#      state: touch
      

#- name: Check if kube api is running
#  shell: "pgrep kube-apiserver"
#  register: running_process
#  ignore_errors: true
#- debug:
#    msg:
#     - "{{ running_process.stdout_lines }}"
#  when: running_process.stdout_lines|length > 0

#- name: If KubeAPI  running get join command
#  become: true
#  shell: "kubeadm token create --print-join-command > /etc/joincluster"
#  when: running_process.stdout_lines|length > 0

#- name: read join file into var
#  become: true
#  shell: "cat /etc/joincluster"
#  when: running_process.stdout_lines|length > 0
#  register: joincluster
#- debug:
#    msg:
#     - "{{ joincluster }}" 
#  when: running_process.stdout_lines|length > 0

#- name: Create join file on ansible host
#  become: true
#  file:
#      path: "/etc/joincluster"
#      state: touch
#  delegate_to: localhost
#  when: running_process.stdout_lines|length > 0

#- name: add contents to ansible host join file
#  become: true
#  copy:
#      dest: "/etc/joincluster"
#      content: |
#        {{ joincluster.stdout }}                        
#  delegate_to: localhost
#  when: running_process.stdout_lines|length > 0

#- name: read kubecfg into var
#  become: true
#  shell: "cat $HOME/.kube/config"
#  register: kubecfg
#  when: running_process.stdout_lines|length > 0

#- name: Create kubecfg file local
#  file:
#      path: "/etc/kubeconfig"
#      state: touch
#  delegate_to: localhost
#  when: running_process.stdout_lines|length > 0

#- name: add contents to file
#  copy:
#      dest: "/etc/kubeconfig"
#      content: |
#        {{ kubecfg.stdout }}                        
#  delegate_to: localhost
#  when: running_process.stdout_lines|length > 0
#- meta: end_host
#  when: running_process.stdout_lines|length > 0


#- name: enable IPv4 forwarding
#  shell: |
#     sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/' /etc/sysctl.conf
#     sysctl -p


#- name: Download Releasekey  
#  become: true
#  shell: "curl -fsSL https://pkgs.k8s.io/core:/stable:/v{{ vardata.k8sversion }}/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg --yes"
#  register: key
#- debug:
#     msg:
#       - "{{ key.stdout }}"



#- name: echo to sources list
#  become: true
#  shell: "echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v{{ vardata.k8sversion }}/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list"
#  register: list
#- debug:
#     msg:
#       - "{{ list.stdout }}"